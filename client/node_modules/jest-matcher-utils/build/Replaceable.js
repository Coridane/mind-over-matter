'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.default = void 0;
<<<<<<< HEAD

var _jestGetType = require('jest-get-type');

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const supportTypes = ['map', 'array', 'object'];

/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
class Replaceable {
  constructor(object) {
    _defineProperty(this, 'object', void 0);

    _defineProperty(this, 'type', void 0);

    this.object = object;
    this.type = (0, _jestGetType.getType)(object);

=======
var _jestGetType = require('jest-get-type');
/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

const supportTypes = ['map', 'array', 'object'];
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
class Replaceable {
  object;
  type;
  constructor(object) {
    this.object = object;
    this.type = (0, _jestGetType.getType)(object);
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
    if (!supportTypes.includes(this.type)) {
      throw new Error(`Type ${this.type} is not support in Replaceable!`);
    }
  }
<<<<<<< HEAD

=======
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
  static isReplaceable(obj1, obj2) {
    const obj1Type = (0, _jestGetType.getType)(obj1);
    const obj2Type = (0, _jestGetType.getType)(obj2);
    return obj1Type === obj2Type && supportTypes.includes(obj1Type);
  }
<<<<<<< HEAD

=======
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
  forEach(cb) {
    if (this.type === 'object') {
      const descriptors = Object.getOwnPropertyDescriptors(this.object);
      [
        ...Object.keys(descriptors),
        ...Object.getOwnPropertySymbols(descriptors)
<<<<<<< HEAD
      ] //@ts-expect-error because typescript do not support symbol key in object
=======
      ]
        //@ts-expect-error because typescript do not support symbol key in object
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
        //https://github.com/microsoft/TypeScript/issues/1863
        .filter(key => descriptors[key].enumerable)
        .forEach(key => {
          cb(this.object[key], key, this.object);
        });
    } else {
      this.object.forEach(cb);
    }
  }
<<<<<<< HEAD

=======
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
  get(key) {
    if (this.type === 'map') {
      return this.object.get(key);
    }
<<<<<<< HEAD

    return this.object[key];
  }

=======
    return this.object[key];
  }
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
  set(key, value) {
    if (this.type === 'map') {
      this.object.set(key, value);
    } else {
      this.object[key] = value;
    }
  }
}
/* eslint-enable */
<<<<<<< HEAD

=======
>>>>>>> 51157e816bbc24e962baca143a6b1386eee11385
exports.default = Replaceable;
